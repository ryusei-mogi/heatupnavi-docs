# 計算ロジック設計書（MVP）

対象：HeatupNavi（iOS 17+）

目的：このアプリの価値の中心である「最安の沸き上げ時間帯」提示について、前提・計算式・選び方・境界条件を固定し、「なぜその時間が最安なのか」を説明できる状態にする。

関連実装：
* `HeatupNavi/Domain/BoilSchedule/CalcEngine.swift`
* `HeatupNavi/Domain/BoilSchedule/COPModel.swift`
* `HeatupNavi/Domain/PricePlan/PricePlan.swift`
* `HeatupNavi/Services/WeatherClient.swift`
* `HeatupNavi/UI/ViewModels/HomeViewModel.swift`

---

## 1. スコープ（MVPでやること / やらないこと）

### 1.1 やること

* 当日の時間スロット（30分）ごとに「同じ熱量を作ると仮定した場合のコスト」を評価する
* 必要な沸き上げ量（熱量）を、前日使用湯量（40℃相当L）から近似する
* WeatherKitの気温からCOP（効率）を簡易モデルで推定する
* スロットを選び、**最大3つの連続区間**にまとめられる範囲で総コスト最小となる時間帯を提案する
* 基準運用（夜優先）との差分として、推定節約額を計算する（ただし入力が揃う場合のみ表示）

### 1.2 やらないこと（将来拡張）

* 機種別（能力・COPカーブ・沸き上げ速度）の最適化
* 給水温の厳密推定（季節・地域・水道水温モデル）
* 待機ロス（タンク放熱）や、日跨ぎの残湯量の精密モデル化
* 市場連動など複雑な料金プランの自動取り込み

---

## 2. 入力（計算に使うデータ）

### 2.1 ユーザー入力

* 前日分の使用湯量（40℃相当）  
  * `liters40`（L）
  * 未入力の場合：提案スケジュール自体は出すために標準量で代用する（MVP）

### 2.2 ユーザー設定

* 昼/夜の単価（円/kWh）と時間帯
  * `TariffSetting` → `PricePlan` により、スロットごとの `priceYenPerKWh[slot]` に変換

### 2.3 外部データ（WeatherKit）

* 当日の時間別気温 `tempC[slot]`（℃）
  * スロットに対して「属する1時間の予報値」を割り当てる（30分なら同じ値が2枠に入る）
  * 当日キャッシュがあればキャッシュを使う（当日中は再取得しない）

### 2.4 内部設定（MVP固定または初期値）

* `slotMinutes`：スロット分（MVPは30）

---

## 3. 前提・固定値（MVPの近似）

### 3.1 熱量換算（L40 → kWh熱）

* 水の比熱に基づく近似として、以下の係数を用いる：
  * `0.001163`（kWh / L / ℃）

### 3.2 給水温の仮定

* 給水温 `Tin = 15℃`（固定）

### 3.3 沸き上げ速度（熱量生産量）

* 1時間あたりの生産熱量を固定する：
  * `HEAT_PER_HOUR = 4.0 kWh熱/時`
* スロット当たりの生産熱量：
  * `HEAT_PER_SLOT = HEAT_PER_HOUR * (slotMinutes / 60)`
  * 例：30分なら `2.0 kWh熱/slot`

### 3.4 COP（効率）簡易モデル

* 外気温→COPの対応点（MVP固定）：
  * -5℃→2.4
  * 0℃→2.8
  * 2℃→3.0
  * 7℃→3.6
  * 16℃→4.6
* 上記の点を線形補間し、`COP ∈ [2.0, 5.0]` にクランプする

---

## 4. 計算式（評価値の定義）

### 4.1 必要熱量（kWh熱）

前日使用湯量（40℃相当）から、同等のお湯を作るための必要熱量（kWh熱）を推定する。

* `E_heat_kWh = liters40 * 0.001163 * (40 - Tin)`

### 4.2 必要スロット数

* `needSlots = ceil(E_heat_kWh / HEAT_PER_SLOT)`
* `needSlots` は `0..N`（Nは当日スロット数）にクリップする
  * クリップした場合は警告フラグ `isNeedSlotsClipped = true` とする

### 4.3 スロットごとのコスト（円）

「同じ熱量（HEAT_PER_SLOT）を作る」と仮定したとき、必要な電力量は `熱量 / COP` なので、

* `kWh_elec_per_slot = HEAT_PER_SLOT / COP(tempC[slot])`
* `costYenPerSlot = kWh_elec_per_slot * priceYenPerKWh[slot]`

つまり **単価が安い**、かつ **気温が高くCOPが高い** スロットほど安くなる。
これが「なぜその時間が最安なのか」の説明の根拠になる。

---

## 5. 提案の選び方（最安時間帯の決定法）

### 5.1 最適化問題としての定義

入力：
* `costYenPerSlot[0..<N]`
* `needSlots`

選ぶもの：
* 選択スロット集合 `S`（複数スロット）

制約：
* `|S| >= needSlots`
* `S` を時系列に並べたとき、連続スロットのまとまり（区間）が **最大3つ**

目的：
* `sum(costYenPerSlot[i] for i in S)` を最小化

補足：
* スロットの離れ具合によっては、区間数制約を満たすために `|S| > needSlots`（ブリッジ用の追加スロット）を選ぶ場合がある。  
  その場合でも追加スロット分のコストは加算されるため、総コスト最小の解が選ばれる。

### 5.2 解法（DP）

スロット数が48程度と小さいため、端末内で確実に解が出るDPを採用する。

状態（`CalcEngine.optimizeSlots`）：
* `i`：0..N（i番目まで見た）
* `k`：0..3（使用した区間数）
* `in`：0/1（現在区間の中か）
* `h`：0..needSlots（選択スロット数、needSlots以上はneedSlotsに丸める）

遷移：
* 選ばない：`(i+1, k, 0, h)`（コスト増なし）
* 選ぶ：
  * `in == 1`：区間継続 → `k` は増えない
  * `in == 0`：新区間開始 → `k+1`
  * `h` は `min(needSlots, h+1)`
  * コストは `+ costYenPerSlot[i]`

採用：
* `i=N` 到達時点で `h=needSlots` を満たす状態のうち、最小コストを採用
* 復元情報を保持して、選ばれたスロット集合 `S` を復元する

### 5.3 表示用区間への変換

復元したスロット集合 `S` を昇順に並べ、連続する部分をまとめて `TimeSegment` にする。

* `startMin = startSlotIndex * slotMinutes`
* `endMin = (endSlotIndex + 1) * slotMinutes`
* `endMin` は「含まない」で統一する
* `order` は0から順に付与する

---

## 6. 比較対象（基準運用）と節約額

### 6.1 基準運用の定義（MVP固定）

「夜時間帯に優先して沸き上げ」を基準とする。

手順：
1. 夜スロット（`isNightSlot == true`）を `costYenPerSlot` 昇順に並べ、上から `needSlots` まで選ぶ
2. 夜だけで足りない場合、全スロットを `costYenPerSlot` 昇順に並べ、残りを補う

補足：
* 基準運用には「最大3区間」制約を付けない（MVPの簡易比較）。

### 6.2 節約額

* `saveYen = baseCostYen - bestCostYen`

表示ルール（MVP）：
* 前日分の使用湯量が **実入力** の場合のみ、節約額を表示・保存する
* 未入力/推定入力の場合は「算出に必要な入力が不足」として節約額表示を保留する

---

## 7. 境界条件・例外時の挙動

### 7.1 気温が取れない / 配列が揃わない

* WeatherKit取得失敗 + 当日キャッシュなし：
  * 計算に必要な `tempC[slot]` が作れないため、Homeでエラー表示（MVP）
* `priceYenPerKWh` / `tempC` / `isNightSlot` の長さが不一致：
  * 計算関数は失敗（nil）を返す

### 7.2 使用湯量が未入力

* 提案スケジュールは出す（標準量で代用）
* 節約額は出さない（根拠が弱いため）

### 7.3 needSlots が1日分に収まらない（クリップ）

* `needSlots > N` の場合は `needSlots = N` にクリップし、警告表示する
* これは「必要量が多すぎて当日枠では足りない可能性がある」状態を示す（MVP）

### 7.4 単価区間の境界

* 昼/夜区間が日付をまたぐ（例：23:00–7:00）場合も判定できる
* `start == end` は「その区間なし」扱い

---

## 8. 検証（テスト観点）

最低限、以下を単体テストで固定する。

* 昼夜跨ぎの単価判定（夜: 23:00–7:00 など）
* COP推定（境界温度と補間）
* DPが「最大3区間」を破らないこと
* `needSlots` の増減に対して、区間の出方が破綻しないこと

---

## 9. 将来拡張の差し替えポイント

* `Tin`（給水温）の推定：地域/季節/水道水温モデルへ差し替え
* `HEAT_PER_HOUR`（沸き上げ速度）：機種別パラメータ化
* `COPModel`：機種別・学習モデル・外気温以外（湿度等）への拡張
* 目的関数：待機ロス、ピーク回避、ユーザー制約（稼働禁止時間など）を追加
* 最適化制約：区間数だけでなく「最短/最長運転」や「開始時刻の固定」などを追加
