# 実装指示書: ソーラーパネル発電量予測を現実に近づける（太陽高度・季節・温度・方角）

## 1. 背景 / 現状
- 現状の発電量予測は `HeatupNavi/Domain/BoilSchedule/SolarPriceAdjuster.swift` の `calculateGeneration()` で、
  - `isDaylight`（WeatherKit）で昼夜判定し
  - 昼の間を単純な `sin()` カーブで近似（方角はピークを前後にシフト）
  - 雲量は線形係数、影は固定係数
  - 気温（パネル温度）や季節（太陽高度/日長）の影響は入っていない
- そのため「太陽が出ている間の発電が一定に見える / 季節差が弱い / 高温時の出力低下が表現できない」状態になり得る。

## 2. 目的（ゴール）
同一地点の「同じパネル容量」でも、下記が反映された“それっぽい”日内発電カーブを得る。
- **日の角度（太陽高度）**: 朝夕が弱く、太陽高度が高い時間帯ほど強い
- **季節**: 冬は総量・ピークが下がり、夏は上がる（緯度依存）
- **温度**: 暑い日は出力が下がる（温度係数）
- **方角/影**: 既存の設定と整合（南/東/西、影の影響）

非ゴール（今回やらない）:
- 気象庁の「日射量」等の外部API連携（現状の固定条件: WeatherKitのみ）
- 積雪/汚れ/パネル劣化の個別モデリング

## 3. 仕様方針（段階導入）
### Stage A（必須 / まず現実寄りに）
1) 太陽位置（高度・方位）を **日時+緯度経度** から計算  
2) 太陽高度から「晴天時の相対出力（0..1）」を作る  
3) パネル面（方角/傾斜）への入射角で補正する  
4) 雲量で減衰する（既存の `cloudCover` を継続利用）  
5) NOCT近似でセル温度を推定し、温度係数で出力補正する  
6) 既存の `learnedScale` は最終段で掛ける（学習は継続）

### Stage B（任意 / 精度を上げる余地）
- WeatherKitから **風速** を取り、セル温度推定を改善（風で冷える）
- `SolarOrientation` を「南/東/西」から「方位角（°）」へ拡張（任意入力）
- 雲量→日射減衰を「線形」から「クリアネス指数」近似へ（チューニング）

## 4. 入力データ（必要なもの）
発電予測は Domain の純粋関数で完結させ、UI/Service から “安全な値” を渡す。
- 日付: `day: Date`（startOfDay）
- 位置: `CLLocationCoordinate2D`（lat/lon）
- タイムゾーン: `TimeZone`（基本は `Calendar.current.timeZone`）
- スロット: `slotMinutes: Int`
- スロット配列: `cloudCovers[]`, `tempsC[]`（既存）

※`isDaylights[]` は Stage A では **使わない（不要）** 方針。  
（太陽高度計算で「地平線より上」を昼扱いにできるため）

## 5. モデル設計（Domain）
### 5.1 追加する型（置き場所）
既存の流れに合わせ、まずは `HeatupNavi/Domain/BoilSchedule/` 配下に追加する。
- `SolarPosition.swift`
  - `static func compute(date: Date, lat: Double, lon: Double, timeZone: TimeZone) -> (elevationRad: Double, azimuthRad: Double)`
- `SolarPVGenerationModel.swift`
  - `static func predictKWPerSlot(...) -> [Double]`
  - `static func predictKWhPerSlot(...) -> [Double]`

### 5.2 太陽位置（おすすめの簡易式）
実装は「近似で良いが、季節と緯度の差が出る」ことを最優先にする。  
（※厳密天文学は不要。テストで破綻しない程度の安定性を担保）

最低限の要件:
- `elevationRad <= 0` のとき発電は 0
- 夏至付近は冬至付近より `elevationRad` が高くなる（同時刻・同地点）

計算に必要な概念（例）:
- 年通日 `N`（1..365/366）
- 太陽赤緯 `δ`
- 時角 `H`
- 緯度 `φ`
- 天頂角 `θz`、高度 `α = π/2 - θz`
- 方位角 `ψ`

※式の選定は Stage A では「NOAA簡易アルゴリズム」相当を採用し、コード内に固定実装する（外部依存を増やさない）。

### 5.3 パネル面への入射（方角・傾斜）
現状設定は `SolarOrientation`（south/east/west）のみで「傾斜」が無い。  
現実味を上げるため、**傾斜角 `tiltDeg` を追加**する（後述: 永続化/UI）。

パネル方位角 `γ` の扱い:
- south: 180°
- east: 90°
- west: 270°

入射角の近似（代表例）:
- 太陽高度 `α`、太陽方位角 `ψ`、パネル傾斜 `β`、パネル方位 `γ`
- `cos(θi) = sin(α) * cos(β) + cos(α) * sin(β) * cos(ψ - γ)`
- `incidence = max(cos(θi), 0)`

これで「朝夕は弱い」「東は午前寄り」「西は午後寄り」が自然に出る。

### 5.4 雲量の減衰（現状維持 + 係数見直し）
現状:
- `cloudFactor = max(1.0 - 0.85 * cloudCover, 0.10)`

Stage A:
- まずはこの形を踏襲しつつ、**最低値（例: 0.15〜0.25）**を調整可能にする
- 将来チューニングに備えて、係数は `SolarPVModelConstants` にまとめる

### 5.5 温度補正（セル温度推定 + 温度係数）
パネル出力はセル温度が上がると低下するため、次を入れる。

推奨の簡易モデル（NOCT）:
- `Gpoa`（面日射相当, W/m²）を 0..1000 近傍で作る（下記 5.6）
- `Tcell = Tamb + (NOCT - 20) / 800 * Gpoa`
  - `Tamb`: 外気温（`tempsC`）
  - `NOCT`: 例 45°C（初期値、設定で変更可にしてもよい）
- 温度係数（出力の相対変化）:
  - `tempFactor = 1 + tempCoeffPerC * (Tcell - 25)`
  - `tempCoeffPerC` は負（例 -0.004 /°C）
  - `tempFactor` は 0.6〜1.1 などにクランプ（異常値防止）

### 5.6 “kWに落とす”ための正規化（重要）
「現実に近い値」にするため、最終的に `panelKW` を基準に kW を作る。

おすすめ:
- `Gpoa = 1000 * clearSkyShape * incidence * cloudFactor`
  - `clearSkyShape` は `sin(α)` 由来の 0..1（例: `max(sin(α), 0)` をそのまま、または指数で丸める）
- `pvKW = panelKW * performanceRatio * (Gpoa / 1000) * tempFactor * shadeFactor`
  - `performanceRatio`（現状 `systemLoss` 0.75）は **命名を改善**し、初期値は 0.80〜0.85 を検討
  - `shadeFactor` は既存の `SolarShade` を継続
- `pvKW *= learnedScale`（最後）
- `pvKWh = pvKW * slotHours`

※厳密には「冬の快晴で定格超え」などもあり得るが、UI/学習安定のため `pvKW <= panelKW * 1.1` 程度で抑える案も検討する（要確認）。

## 6. データ設計（SwiftData / 設定）
### 6.1 SolarSettingに追加する項目（Stage A）
既存 `SolarSetting` / `SolarSettingDTO` に追加し、未設定はデフォルトで扱う。
- `tiltDeg: Double?`（例: 30.0）
- `performanceRatio: Double?`（例: 0.82）
- `tempCoeffPerC: Double?`（例: -0.004）
- `noctC: Double?`（例: 45.0）

注意:
- SwiftDataの並行処理ルールに従い、actor間はDTOでやり取りする
- `ensureSolarSetting()` のデフォルト値も更新する

## 7. サービス設計（WeatherKit）
Stage Aは追加取得なしで進める（`cloudCover` と `temperature` で成立）。

Stage B（任意）:
- `WeatherClient.fetchFromWeatherKit()` で `windSpeed` を取り、`WeatherLoadResult` / `HourlyWeatherCache` に保存する
- 保存対象は “必要最小” に限定（風速だけ）

## 8. 既存処理への組み込み点
### 8.1 SolarPriceAdjusterのI/F変更（Stage A）
現状 `SolarPriceAdjuster.adjust()` は solar側で日時・位置を知らないため、太陽位置が計算できない。  
よって引数を追加する。

案:
- `adjust(basePrices:..., solarSetting:..., cloudCovers:..., tempsC:..., slotMinutes:..., day: Date, location: CLLocationCoordinate2D, timeZone: TimeZone)`

呼び出し元:
- `HeatupNavi/UI/ViewModels/HomeViewModel.swift` から、保存済み `location` と `today` を渡す

### 8.2 既存の `isDaylights` の扱い
- Stage Aでは原則未使用にし、`SolarPosition` で判定
- ただし保険として、太陽位置計算が破綻した場合のみ `isDaylights` をフォールバックに使う（0/1判定）

## 9. UI（設定画面）
追加設定は「分からない人が触らなくて良い」設計にする。
- `SettingsView` のソーラーセクションに `DisclosureGroup("詳細設定")` を追加
- 入力UI案:
  - 傾斜角: 0〜60°（Slider + 数値表示）
  - パネル温度係数: 既定値を固定表示（編集可にするなら注意書き付き）
  - PR（performanceRatio）: 0.6〜0.95（Slider）
- `docs/FRONTEND_DESIGN_PHILOSOPHY.md` の方針に沿い、「ただのフォーム」にならないよう
  - 触る意義が伝わる短い説明
  - デフォルト推奨（“迷ったらそのまま”）
  - 変更したら結果が変わるフィードバック（例: 「予測日発電量(目安)」表示 ※表示追加は別タスクでも可）

## 10. テスト（最低限）
既存 `HeatupNaviTests/SolarPriceAdjusterTests.swift` を土台に、モデル単体テストを追加する（推奨）。

追加したい観点（Stage A）:
- **日内カーブ**: 朝/昼/夕で単調に変化し、昼が最大（同条件）
- **季節差**: 同じ時刻でも夏の方が冬より出力が高い（同地点）
- **温度差**: 同じ日射条件で高温日の方が出力が低い
- **方角差**: 東向きは午前寄り、西向きは午後寄り（ピーク時刻がずれる）
- **雲量差**: cloudCover=1.0 の方が 0.0 より総量が小さい

テスト用の固定条件例:
- 位置: 東京近郊（lat 35.68, lon 139.76）
- 日付: 2026-01-15 と 2026-07-15（ローカルTZ固定）

## 11. 確認観点（実機/シミュレータ）
- 同じ設定でも、冬と夏で “予測日発電量（total）” が変わる
- 「晴れ・雲多め」で補正が効く（単価補正が弱まる）
- 真夏日相当（気温高）で出力が少し落ちる
- 既存の学習（発電実績入力 → `learnedScale`）が引き続き効く（極端に暴れない）

## 12. 実装タスク分解（チェックリスト）
1) Domain: `SolarPosition` / `SolarPVGenerationModel` を追加（`HeatupNavi/Domain/BoilSchedule/`）
2) Domain: `SolarPriceAdjuster.calculateGeneration()` を新モデルへ置換（sin近似を削除）
3) Call site: `HomeViewModel` から day/location/timeZone を渡す
4) Persistence: `SolarSetting` / DTO / Store のデフォルト値を拡張（tilt/PR/温度係数/NOCT）
5) UI: `SettingsView` / `SettingsViewModel` に詳細設定を追加
6) Tests: モデル単体 or adjuster のテストを追加/更新
7) 動作確認: 代表地点/日付で予測値が極端にならないことを確認
8) `progress.md` を更新

## 13. 未確定事項（確認が必要なら先に決める）
以下は実装前に「既定値」を決める必要がある（迷ったら Stage A の推奨値で開始）。
- `tiltDeg` の初期値（30° / 緯度同等 / ユーザー入力必須のどれにするか）
- `performanceRatio` の初期値（0.75のまま / 0.82へ変更）
- `tempCoeffPerC` と `NOCT` をユーザー編集可能にするか（基本は詳細設定で任意）

