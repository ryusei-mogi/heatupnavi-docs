# 機能設計書（MVP）

対象：HeatupNavi（iOS 17+ / SwiftUI / Swift Concurrency / SwiftData / WeatherKit / Core Location / UserNotifications）

目的：機能ごとの「入力 → 処理 → 出力」を固定し、実装・テストの基準を揃える。

関連ドキュメント：
* `docs/要件定義書.md`
* `docs/実装指示書.md`
* `docs/全体設計書.md`
* `docs/画面設計書.md`
* `docs/画面遷移図.md`

---

## 1. 前提（共通）

### 1.1 日付キー（DayKey）

* 日別データは **当日0:00（ローカル）** に丸めた `Date` をキーにする（`startOfDay`）。
* 「前日分の使用湯量」は `DayKey.yesterday()` を対象日とする。

### 1.2 時間スロット

* 1日（1440分）を `slotMinutes` で等分したスロット列で評価する。
* MVPは `slotMinutes = 30` を標準とする（`AppSetting.timeSlotMinutes` に保持）。
* スロット数：`N = 1440 / slotMinutes`（30分なら48）

### 1.3 設定・保存の基本

* 永続化は SwiftData（`AppModelActor`）に集約する。
* ViewModel から SwiftData の `@Model` は直接扱わず、DTO（値型）でやり取りする。

---

## 2. 機能一覧

| ID | 機能名 | 主な入口 | 主な出力 |
| --- | --- | --- | --- |
| F-01 | 起動時ルーティング | 起動 / 通知タップ | Setup または Home を表示 |
| F-02 | 自宅位置の登録（初回/再登録） | Setup / 設定 | HomeLocation を保存 |
| F-03 | 通知の許可・予約・停止 | Setup / 設定 / Home起動時 | 7日分ローカル通知を予約/削除 |
| F-04 | 電気単価（昼/夜）設定 | 設定 | TariffSetting を保存 |
| F-05 | 使用湯量入力（前日分） | 使用湯量入力 | UsageEntry を保存 |
| F-06 | 天気取得（当日）＋キャッシュ | Home（更新/起動） | HourlyWeatherCache を保存・利用 |
| F-07 | 最安スケジュール計算（最大3枠） | Home（更新/起動） | TimeSegment（最大3）を表示 |
| F-08 | 節約額算出（日/月/年）＋結果保存 | Home（更新/起動） | CalcResult を保存・節約額表示 |

---

## 3. 機能詳細

## F-01 起動時ルーティング

関連：`HeatupNavi/App/AppEntry.swift` / `HeatupNavi/App/RootView.swift`

### 入力

* アプリ起動
* ローカル通知タップ（`userInfo["route"]`）
* 永続データ：`HomeLocation` の有無

### 処理手順

1. 起動時に `AppModelActor.ensureDefaults()` を実行し、初期設定（`AppSetting` / `TariffSetting`）を担保する。
2. `HomeLocation` が存在するかを確認する。
3. 分岐する。
   * 未登録 → Setup を表示
   * 登録済み → Home を表示
4. 通知タップ時は、`route == "cheapest"` の場合に NavigationStack をリセットし、Homeへ戻す。

### 出力

* Setup または Home の表示
* （通知タップ）Homeへ直行

### 例外時の挙動

* 永続化の取得に失敗：安全側として Setup 扱い（ホーム位置未登録と同等）

### 制約（MVP）

* ルーティング先は Home 固定（通知タップは「最安設定の確認」用途）

### テスト観点

* HomeLocation 未登録で Setup に入る
* HomeLocation 登録済みで Home に入る
* 通知タップで Home に戻る（他画面表示中でも戻る）

---

## F-02 自宅位置の登録（初回/再登録）

関連：`HeatupNavi/Services/LocationClient.swift` / `HeatupNavi/Persistence/Store.swift` / `SetupViewModel` / `SettingsViewModel`

### 入力

* ユーザー操作
  * Setup：`現在地を取得`
  * 設定：`自宅を再登録`
* OS権限：位置情報（When In Use）

### 処理手順

1. 位置権限が未決定なら `requestWhenInUseAuthorization()` を実行する。
2. 許可状態なら `requestLocation()` で **現在地を1回取得** する。
3. 取得した `lat/lon` を `HomeLocation` として保存する（既存があれば置換）。

### 出力

* 永続化：`HomeLocation(lat, lon, savedAt)`
* 画面：成功状態（Setupでは「位置情報は保存済み」へ）

### 例外時の挙動

* 権限拒否：エラー表示（例：`位置情報の許可が必要です。`）
* 取得失敗：エラー表示（例：`位置情報を取得できませんでした。`）

### 制約（MVP）

* 位置情報は「初回セットアップ（または再登録）」のときだけ取得し、常時追跡しない。
* 位置が取れない/拒否の場合でもアプリが使える導線（手入力・前回値利用など）は **将来拡張** とする（要件対応が必要）。

### テスト観点

* 許可→取得→保存で HomeLocation が1件になる（再登録で置換される）
* 拒否/失敗時にエラーメッセージが表示され、再試行できる

---

## F-03 通知の許可・予約・停止

関連：`HeatupNavi/Services/NotificationScheduler.swift` / `HeatupNavi/App/AppEntry.swift` / `SetupViewModel` / `SettingsViewModel` / `HomeViewModel`

### 入力

* ユーザー操作
  * Setup：`通知を許可`
  * 設定：通知トグル ON/OFF
* アプリ起動（Home表示時のリスケジュール）
* OS権限：通知

### 処理手順（ON）

1. `UNUserNotificationCenter.requestAuthorization(...)` を実行する。
2. 許可されたら、先の `days=7` 日分の通知を予約し直す。
   * 既存（pending + delivered）を削除してから追加する。
   * 通知時刻：毎日 7:00（固定）
   * 文言：`今日のエコキュート最安設定の確認`（固定）
   * `userInfo["route"]="cheapest"` を付与する。
3. 永続化：`AppSetting.notificationEnabled = true` を保存する。

### 処理手順（OFF）

1. 予約中（pending）と表示済み（delivered）の通知を削除する。
2. 永続化：`AppSetting.notificationEnabled = false` を保存する。

### 処理手順（Home表示時のリスケジュール）

* `AppSetting.notificationEnabled == true` の場合、Home表示時に必要なら `days=7` の予約を作り直す。
  * 「更新」ボタン押下ではリスケジュールしない（再計算のみ）

### 出力

* OS：ローカル通知の予約/削除
* 永続化：通知ON/OFF
* 画面：許可されていない場合は警告表示（例：`通知が許可されていません`）

### 例外時の挙動

* 許可されない（拒否/エラー）：通知は予約しない。
  * Setup/設定：エラー表示（`通知が許可されていません。` など）
  * 設定：トグルはOFF相当に戻す
* 予約追加に失敗：エラー表示（設定時）／ログ出力（Home起動時）

### 制約（MVP）

* 通知内容は固定文言（おすすめ時刻を埋め込まない）。
* バックグラウンド定時実行に依存しない（起動時・設定変更時に予約を作り直す）。
* Setup完了条件は「通知許可必須」にしない（拒否でもアプリ利用可能）ことが望ましい（現状実装は要調整）。

### テスト観点

* ONで7日分が予約される（過去時刻は除外される）
* OFFで pending / delivered が削除される
* 通知タップで Home に戻る（`route == "cheapest"`）

---

## F-04 電気単価（昼/夜）設定

関連：`HeatupNavi/Domain/PricePlan/PricePlan.swift` / `HeatupNavi/Persistence/Store.swift` / `SettingsViewModel`

### 入力

* ユーザー入力（設定画面）
  * 夜：開始/終了（時刻）、単価（円/kWh）
  * 昼：開始/終了（時刻）、単価（円/kWh）

### 処理手順

1. UIの時刻入力を「分（0〜1439）」へ変換する。
2. `TariffSetting` を保存する（既存は置換）。
3. Homeの次回更新時に、当日スロットの `priceYenPerKWh[]` を再生成する。

### 出力

* 永続化：`TariffSetting(...)`

### 例外時の挙動

* 保存失敗：エラー表示

### 制約（MVP）

* 区分は昼/夜の2つのみ（将来拡張）
* 区間が日付をまたぐ（例：23:00〜7:00）ことに対応する
* `start == end` は「その区間なし」扱い（判定はfalse）
* 未指定時間の単価は昼単価を既定とする（MVPの簡易ルール）

### テスト観点

* 夜区間が跨ぎでも `isInNight` が正しく判定できる
* スロット配列が `1440/slotMinutes` 件になる

---

## F-05 使用湯量入力（前日分）

関連：`HeatupNavi/UI/Views/UsageInputView.swift` / `UsageInputViewModel` / `AppModelActor.saveUsageEntry`

### 入力

* ユーザー入力：40℃相当使用湯量（L）
* 対象日：前日（Homeから遷移した場合）

### 処理手順

1. 画面表示時に、対象日の `UsageEntry` があれば読み込み、入力欄に反映する。
2. `保存` 押下で入力値を数値に変換し、0以上をチェックする。
3. `UsageEntry(day, liters40, createdAt)` を保存する（同一日の既存は置換）。

### 出力

* 永続化：`UsageEntry`
* 画面：成功表示（`保存しました`）

### 例外時の挙動

* 数値に変換できない / 0未満：`数値を入力してください。`
* 保存失敗：エラー表示

### 制約（MVP）

* 入力単位はL（40℃相当）固定
* 未来日入力や詳細な履歴編集UIは対象外

### テスト観点

* 既存値があれば初期表示で復元される
* 保存で同一日のレコードが1件になる

---

## F-06 天気取得（当日）＋キャッシュ

関連：`HeatupNavi/Services/WeatherClient.swift` / `AppModelActor.fetchWeatherCache` / `saveWeatherCache`

### 入力

* 日付：当日（`DayKey.today()`）
* 自宅座標：`HomeLocation(lat, lon)`
* スロット分：`slotMinutes`

### 処理手順

1. 当日キーの `HourlyWeatherCache[]` を取得する。
2. キャッシュ判定：
   * 件数が `expectedCount = 1440/slotMinutes` と一致
   → キャッシュを返す（`isFromCache = true`）
3. キャッシュが使えない場合、WeatherKit（hourly）から当日分の気温を取得する（当日1回のみ）。
4. スロット開始時刻が属する「時」の気温を当該スロットに割り当てる。
   * 30分スロットの場合、同じ時刻の気温が2スロットに割り当てられる（MVPの簡易対応）
5. 取得成功時は `HourlyWeatherCache` を全件保存し、結果を返す（`isFromCache = false`）
6. 取得失敗時は、当日キャッシュが存在する場合に限りフォールバックして返す。

### 出力

* 画面：天気更新日時（取得日時 or キャッシュの最新日時）
* 永続化：`HourlyWeatherCache(day, slotIndex, tempC, fetchedAt)`（当日分を置換）
* 永続化（補助）：WeatherKitで取得した場合に `AppSetting.lastWeatherFetchDay = today` を更新

### 例外時の挙動

* WeatherKit取得失敗 + 当日キャッシュなし：エラー（`天気を取得できませんでした。` 相当）
* 取得データが不足（必要な時刻が埋まらない）：エラー（`weatherUnavailable`）

### 制約（MVP）

* 取得対象は当日の時間別気温のみ
* 取得頻度は日次で抑制（当日キャッシュがあれば再取得しない）

### テスト観点

* 当日キャッシュがあればキャッシュが返る
* 当日キャッシュが無ければ WeatherKit で取得し、保存が作成される
* 取得失敗時にキャッシュがあればフォールバックする

---

## F-07 最安スケジュール計算（最大3枠）

関連：`HeatupNavi/Domain/BoilSchedule/CalcEngine.swift` / `COPModel.swift`

### 入力

* 当日スロット列（長さN）
  * `priceYenPerKWh[slot]`
  * `tempC[slot]`
  * `isNightSlot[slot]`（基準運用用）
* 使用湯量：`liters40`
* 設定：`slotMinutes`

### 処理手順（必要量）

1. 固定仮定（MVP）
   * 給水温：`Tin = 15℃`
   * 沸き上げ速度（熱量）：`HEAT_PER_HOUR = 4.0 kWh熱/時`
2. 必要熱量（kWh熱）
   * `E_heat_kWh = liters40 * 0.001163 * (40 - Tin)`
3. 1スロットで作れる熱量
   * `HEAT_PER_SLOT = HEAT_PER_HOUR * (slotMinutes/60)`
4. 必要スロット数
   * `needSlots = ceil(E_heat_kWh / HEAT_PER_SLOT)` を 0..N にクリップ
   * クリップした場合は警告フラグを立てる（`isNeedSlotsClipped`）

### 処理手順（COP）

* 外気温→COP（簡易モデル、線形補間＋クランプ）
  * 点：(-5→2.4), (0→2.8), (2→3.0), (7→3.6), (16→4.6)
  * `COP ∈ [2.0, 5.0]` に丸める

### 処理手順（スロットコスト）

* 1スロットのコスト（円）
  * `costPerSlotYen = (HEAT_PER_SLOT / COP[slot]) * priceYenPerKWh[slot]`

### 処理手順（最安スロット選択：最大3区間）

* 条件
  * 選ぶスロット数 ≥ `needSlots`
  * 選んだスロットは **最大3つの連続区間** にまとめられる
  * 合計コスト最小
* 解法：動的計画法（DP）
  * 状態：`i`（位置）/ `k`（区間数0..3）/ `in`（区間内0/1）/ `h`（選択数0..needSlots）
  * 遷移：選ばない（区間外へ）／選ぶ（区間継続 or 新規区間開始）
  * 最小コストを採用し、選択スロットを復元する
* 復元後、連続スロットを `TimeSegment(day, startMin, endMin, order)` にまとめる（最大3つになる想定）。

### 処理手順（基準運用）

* 基準：夜時間帯を優先して安い順に `needSlots` 分を選ぶ
* 夜だけで足りない場合：全体から安い順に補う
* 区間数制約は付けない（MVPの簡易比較）

### 出力

* `segments[]`（最大3区間）
* `baseCostYen` / `bestCostYen` / `saveYen`（基準−提案）
* `needSlots` / `isNeedSlotsClipped`

### 例外時の挙動

* 配列長不一致／不正：計算失敗（nil）
* DPで解が見つからない：計算失敗（nil）

### 制約（MVP）

* 機種固有の効率カーブや沸き上げ速度は未対応（固定値）
* 待機ロス等の精密モデルは未対応

### テスト観点

* 昼夜跨ぎの単価判定が正しい
* COP境界・補間が正しい
* 出力区間数が3以下に収まる
* `needSlots` の算出が想定通り増減する

---

## F-08 節約額算出（日/月/年）＋結果保存

関連：`HeatupNavi/UI/ViewModels/HomeViewModel.swift` / `AppModelActor.saveCalcResult` / `fetchRecentCalcResults`

### 入力

* F-07 の計算結果
* 使用湯量の状態
  * 前日入力あり（actual）／前回値代用（estimated）／未入力（missing）

### 処理手順

1. Homeは「おすすめ時間帯（segments）」は常に算出して表示する（入力不足でも表示は可能）。
2. 節約額表示・結果保存は **前日分の使用湯量が入力されている場合（actual）** に限定する。
   * `saveYenDay = baseCostYen - bestCostYen`
   * 当日の `CalcResult` を保存する（同一日があれば置換）
3. 月/年は直近7日（結果がある日だけ）の平均節約額から換算する。
   * `avgSaveYen = sum(saveYen) / count`
   * 月：`avgSaveYen * 30`
   * 年：`avgSaveYen * 365`
4. 前日入力がない場合は、節約額は非表示（「入力不足」表示）とする。

### 出力

* 画面：節約額（今日/月/年）または「算出に必要な入力が不足しています」
* 永続化：`CalcResult(day, baseCostYen, bestCostYen, saveYen, computedAt)` と `TimeSegment[]`

### 例外時の挙動

* 保存失敗：エラー表示（MVPでは画面内メッセージ）
* 直近結果が0件：月/年は `—` 表示

### 制約（MVP）

* 未入力時の節約額は「保留」扱い（推定値での節約額表示はしない）
* 月/年は 30/365 の固定換算（暦月・うるう年は考慮しない）

### テスト観点

* 前日入力ありで saveYenDay が表示され、CalcResult が保存される
* 直近結果件数に応じて月/年が変化する
* 未入力時は節約額が非表示になる
