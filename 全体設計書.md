# 全体設計書（構成設計）

対象：HeatupNavi（iOS 17+ / SwiftUI / Swift Concurrency / SwiftData / WeatherKit / Core Location / UserNotifications）

---

## 1. 背景と目的

機能が増えると「どこに何を書くべきか」が崩れやすく、改修時の衝突や作り直しが発生しやすい。
本書では、アプリを **画面（UI）・計算（Domain）・外部取得（Services）・保存（Persistence）・通知** に分け、責務と依存関係を固定します。

---

## 2. 全体像（レイヤと依存）

### 2.1 レイヤ

| レイヤ | 役割 | 主な置き場所 |
| --- | --- | --- |
| App | 起動・ルーティング・DI（依存の注入） | `HeatupNavi/App/` |
| UI | 画面描画 + 状態管理（MVVM） | `HeatupNavi/UI/` |
| Domain | 計算ロジック（最安スケジュール/節約額など） | `HeatupNavi/Domain/` |
| Services | 外部取得（WeatherKit/Location/通知） | `HeatupNavi/Services/` |
| Persistence | 端末内保存（SwiftData）と永続I/F | `HeatupNavi/Persistence/` |
| Support | 共通（エラー/日付/フォーマッタ/ログ） | `HeatupNavi/Support/` |

### 2.2 依存ルール（原則）

* **上位 → 下位** の一方向依存に寄せる（循環依存を作らない）
  * App → UI
  * UI → Domain / Services / Persistence / Support
  * Services → Persistence / Support（キャッシュなどで必要な場合のみ）
  * Domain → Foundation（原則）+ 値型（DTO/プリミティブ）  
* **禁止（例）**
  * Domain が SwiftUI / SwiftData / WeatherKit / UserNotifications / CoreLocation を直接参照しない
  * SwiftData の `@Model` を actor をまたいで渡さない（DTOに変換してやり取りする）
  * “毎朝バックグラウンドで計算して通知更新” に依存しない（通知は先に予約してOSに任せる）

---

## 3. ディレクトリ構成（現状）

* `HeatupNavi/App/`
  * `AppEntry.swift`：アプリ起動点、ModelContainer注入、通知デリゲート設定
  * `RootView.swift`：セットアップ完了判定、画面切り替え（Setup/Home）
  * `Route.swift`：画面遷移の enum
* `HeatupNavi/UI/`
  * `Views/`：SwiftUI View（描画と軽いイベントのみ）
  * `ViewModels/`：状態管理役（`@MainActor`、非同期処理の起点）
* `HeatupNavi/Domain/`
  * `PricePlan/`：昼/夜単価の判定と1日スロット配列化
  * `BoilSchedule/`：最安スケジュール計算（DP）とCOP簡易モデル
* `HeatupNavi/Services/`
  * `WeatherClient.swift`：WeatherKit取得 + SwiftDataキャッシュ（当日中は保存値を使用）
  * `LocationClient.swift`：初回（再登録）に一回だけ現在地取得
  * `NotificationScheduler.swift`：ローカル通知の許可/予約/削除、タップルーティング
* `HeatupNavi/Persistence/`
  * `Models/Models.swift`：SwiftData `@Model`
  * `Store.swift`：`ModelContainer` 構築、`@ModelActor`（永続I/Fの集約）
  * `DTOs.swift`：actor境界を越えて渡す値型
* `HeatupNavi/Support/`
  * `Errors.swift` / `DateUtils.swift` / `Formatters.swift` / `Logging.swift`
* `HeatupNaviTests/`
  * `CalcEngineTests.swift`：計算ロジックの単体テスト

---

## 4. 主要コンポーネントと責務

### 4.1 App（起動・ルーティング）

* `HeatupNavi/App/AppEntry.swift`
  * `ModelContainer` を生成し、SwiftUI に注入（`.modelContainer(container)`）
  * `AppModelActor` を生成し、UI層へ渡す（永続I/Fの入口）
  * `UNUserNotificationCenter` の delegate を設定し、通知タップをルーティングへ接続
* `HeatupNavi/App/RootView.swift`
  * `AppState.isSetupComplete` で Setup/Home を切り替える
  * NavigationStack と `Route` による画面遷移の定義

### 4.2 UI（View / ViewModel）

* View（`HeatupNavi/UI/Views/`）
  * **描画と軽いイベントのみ**（ボタン押下で ViewModel を呼ぶ程度）
  * SwiftData を直接触らない（`@Query` を乱用しない）
* ViewModel（`HeatupNavi/UI/ViewModels/`）
  * 画面状態（`@Published`）を持つ（`@MainActor` を基本）
  * 非同期処理の起点：`Task { await ... }` で Services/Store/Domain を呼ぶ
  * 画面遷移で不要になる処理はキャンセルできる形を保つ（例：`HomeViewModel.task`）

代表例：
* Setup：`SetupViewModel` → `LocationClient` / `NotificationScheduler` → `AppModelActor` 保存
* Home：`HomeViewModel`
  * Tariff（単価）→ `PricePlan` でスロット化
  * Weather（気温）→ `WeatherClient` で取得/キャッシュ
  * 計算 → `CalcEngine` で最安区間と節約額を算出
  * 結果保存（必要条件が揃う場合）→ `AppModelActor.saveCalcResult(...)`

### 4.3 Domain（計算）

* `HeatupNavi/Domain/PricePlan/PricePlan.swift`
  * 昼/夜の区間判定（跨ぎ対応）と、スロット配列 `pricesForDay(slotMinutes:)` を提供
* `HeatupNavi/Domain/BoilSchedule/`
  * `COPModel.swift`：外気温→COP（簡易モデル）
  * `CalcEngine.swift`：必要スロット数の推定、スロット選択の最適化（最大3区間）、基準運用との差分

Domain層の約束：
* 入出力は **値（Double/Int/Date/DTO）** に限定する
* 副作用（保存/通知/通信）を持たない

### 4.4 Services（外部取得）

* `WeatherClient`
  * WeatherKit から当日スロットの気温を取得
  * SwiftData（`HourlyWeatherCache`）に保存し、当日キャッシュがあれば再取得しない
  * 取得失敗時は、当日キャッシュが残っていればフォールバックする
* `LocationClient`
  * `requestWhenInUseAuthorization()` → `requestLocation()` の1回取得
  * 精度は `kCLLocationAccuracyKilometer`（天気用途に寄せる）
* `NotificationScheduler`
  * 通知許可の取得、予約（例：7日分）、削除（pending+delivered）
  * 通知タップ時は `NotificationDelegate` を経由して Home へルーティング

通知設計の原則：
* バックグラウンド定時実行に依存しない
* 「アプリ起動時」や「設定変更時」に **先の数日分の予約を作り直す**

### 4.5 Persistence（SwiftData）

* `@Model`：`HomeLocation` / `TariffSetting` / `AppSetting` / `UsageEntry` / `CalcResult` / `TimeSegment` / `HourlyWeatherCache`
* `Store.swift`
  * `AppStore.modelContainer`：SwiftDataの入口
  * `@ModelActor AppModelActor`：追加/更新/取得を集約（UIから直接モデルを操作しない）
* `DTOs.swift`
  * `@Model` を **actor境界の外へ出さない** ための値型（ViewModel/Domainへ渡す）

---

## 5. 代表的な処理フロー（どこが動くか）

### 5.1 初回セットアップ

1. `RootView` が `AppState.refreshSetupStatus()` を呼び、`HomeLocation` の有無で分岐
2. `SetupView` → `SetupViewModel.requestLocation()`
   * `LocationClient.requestLocation()` → `AppModelActor.saveHomeLocation(...)`
3. `SetupView` → `SetupViewModel.requestNotifications()`
   * `NotificationScheduler.requestAuthorization()` → `scheduleDailyReminders(days: 7)`  
   * `AppModelActor.updateAppSetting(notificationEnabled: true)`

### 5.2 ホーム画面（おすすめ計算）

1. `HomeView.onAppear` → `HomeViewModel.load()` → `refresh()`
2. `AppModelActor.ensureDefaults()`（設定の初期値を担保）
3. Tariff取得 → `PricePlan` で `prices[]` と `isNightSlot[]` を生成
4. 位置取得 → `WeatherClient.loadHourlyTemperatures(...)`（キャッシュ優先）
5. 使用湯量（前日）取得（無ければ前回値、さらに無ければ標準量）
6. `CalcEngine.compute(...)` で `segments` と `saveYen` を算出
7. 条件が揃う場合（現状：前日入力あり）に `CalcResult` を保存し、直近7日平均で月/年を算出

### 5.3 設定変更

* 単価：`SettingsViewModel.saveTariff()` → `AppModelActor.saveTariffSetting(dto)`
* 通知：`SettingsViewModel.toggleNotification(_:)`
  * ON：許可→7日分予約→`AppSetting.notificationEnabled = true`
  * OFF：予約削除→`AppSetting.notificationEnabled = false`
* 自宅再登録：`SettingsViewModel.reregisterLocation()` → `LocationClient` → `saveHomeLocation(...)`

---

## 6. 変更するときの「触る場所」早見

* 画面追加・導線変更：`HeatupNavi/App/RootView.swift` と `HeatupNavi/App/Route.swift`、および `HeatupNavi/UI/Views/`・`HeatupNavi/UI/ViewModels/`
* 計算式（COP/必要量/最適化）変更：`HeatupNavi/Domain/BoilSchedule/` と `HeatupNaviTests/CalcEngineTests.swift`
* 昼/夜の判定やプラン拡張：`HeatupNavi/Domain/PricePlan/PricePlan.swift`（必要なら `Persistence` の設定モデルも）
* 天気の取得範囲・頻度・キャッシュ方針：`HeatupNavi/Services/WeatherClient.swift` と `HeatupNavi/Persistence/Models/Models.swift`（`HourlyWeatherCache`）
* 通知文言・予約ルール変更：`HeatupNavi/Services/NotificationScheduler.swift` と `HeatupNavi/App/AppEntry.swift`
* 保存項目や永続I/Fの追加：`HeatupNavi/Persistence/Models/Models.swift` と `HeatupNavi/Persistence/Store.swift`（DTOも追加）
